<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jvm on 吾月</title>
    <link>http://moonye.me/tags/jvm/index.xml</link>
    <description>Recent content in Jvm on 吾月</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="http://moonye.me/tags/jvm/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Java 如何查找 Classes</title>
      <link>http://moonye.me/tech/how-classes-are-found/</link>
      <pubDate>Mon, 06 Mar 2017 00:19:52 +0800</pubDate>
      
      <guid>http://moonye.me/tech/how-classes-are-found/</guid>
      <description>

&lt;p&gt;JDK 提供了很多构建 java 程序的工具，比如 java、javac、javadoc、jdb 等。因为 eclipse 、IntelliJ IDEA 等 IDE 给我们提供了极大的便利，我们很少直接接触到这些基本的工具，但在实际的工作中，我们总会碰到与之相关的东西，比如 java 程序的部署和运行。了解这些知识可以让我们更加从容面对复杂的实际情形，Oracle 官方文档对这些话题提供了不错的参考，本系列文章是对&lt;a href=&#34;http://docs.oracle.com/javase/8/docs/technotes/tools/windows/toc.html&#34; target=&#34;_blank&#34;&gt;此处文档&lt;/a&gt;的梳理和总结，后续若有机会的话，会对其中涉及的话题进一步的深入完善。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java&lt;/code&gt; 命令被用于启动 java 程序，当被调用时，它会从用户的输入和环境中收集信息并引导 java 虚拟机（JVM），由 JVM 处理接下来的工作。&lt;/p&gt;

&lt;h1 id=&#34;java-运行时如何查找-class&#34;&gt;Java 运行时如何查找 Class&lt;/h1&gt;

&lt;p&gt;JVM 会按照顺序依次查找并加载以下三种类：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bootstrap classes&lt;/strong&gt; 它们是构成 java 平台的类，比如位于&lt;code&gt;JDK/jre/lib/&lt;/code&gt;中的 rt.jar 和 其他一些重要的 jar 文件。oracle 官网 tutorial 文档中&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/ext/basics/load.html&#34; target=&#34;_blank&#34;&gt;一处&lt;/a&gt;提到的 i18n.jar，&lt;a href=&#34;https://bugs.openjdk.java.net/browse/JDK-4412570&#34; target=&#34;_blank&#34;&gt;据了解&lt;/a&gt;，已经被 charset.jar 取代，请各位了解准确信息的朋友斧正。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Extension classes&lt;/strong&gt; 位于 &lt;code&gt;JDK/jre/lib/ext&lt;/code&gt; 目录下的 jar 文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;User classes&lt;/strong&gt; 由开发者和第三方定义的 class 文件。通过 &lt;code&gt;-classpath&lt;/code&gt; 命令行选项或者 &lt;code&gt;CLASSPATH&lt;/code&gt; 环境变量指定位置。&lt;/p&gt;

&lt;p&gt;用户一般只需指定 user classes 的位置，Bootstrap classes 和 Extension classes 会被自动处理。&lt;/p&gt;

&lt;h1 id=&#34;java-运行时如何查找-bootstrap-classes&#34;&gt;Java 运行时如何查找 Bootstrap classes&lt;/h1&gt;

&lt;p&gt;指明 Bootstrap classes 位置的信息存储在 &lt;code&gt;sun.boot.class.path&lt;/code&gt; 系统属性中，它在方法 java.lang.System.initProperties 中被初始化，此方法是由 C++ 实现的 Native Method。Bootstrap classes 位置可以使用非标准选项 &lt;code&gt;-Xbootclasspath&lt;/code&gt; 重新指定。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;JDK/lib/tools.jar&lt;/code&gt; 并不属于 Bootstrap classes，但在调起 &lt;code&gt;java&lt;/code&gt; 命令时，它会被自动拓展到 user class path 中，而 &lt;code&gt;javac&lt;/code&gt; 和 &lt;code&gt;javadoc&lt;/code&gt; 命令在处理源代码时，并不会这样。&lt;/p&gt;

&lt;h1 id=&#34;java-运行时如何查找-extension-classes&#34;&gt;Java 运行时如何查找 Extension classes&lt;/h1&gt;

&lt;p&gt;位于 &lt;code&gt;JDK/jre/lib/ext&lt;/code&gt; 的 class 文件必须包含在 jar 或者 zip 文件中，裸 class 文件不会被查找。如果存在多个 jar 文件，而且这些 jar 文件中包含有相同 class，则这种情况下这些 Class 的加载是未定义的行为。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;smart­extension1_0.jar contains class smart.extension.Smart
smart­extension1_1.jar contains class smart.extension.Smart
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;java-运行时如何查找-user-classes&#34;&gt;Java 运行时如何查找 User classes&lt;/h1&gt;

&lt;p&gt;user class path 是一系列包含有 Class 文件的目录、jar文件、zip文件。&lt;/p&gt;

&lt;p&gt;如果 &lt;code&gt;com.mypackage.MyClass&lt;/code&gt; 位于 &lt;code&gt;myclasses&lt;/code&gt; 目录下，则这个目录必须被包含在 user class path 中，class 文件的全路径为 &lt;code&gt;/myclasses/com/mypackage/MyClass.class&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果 &lt;code&gt;com.mypackage.MyClass&lt;/code&gt; 位于一个名为 &lt;code&gt;myclasses.jar&lt;/code&gt; 的归档文件中，则这个归档文件必须被包含在 user class path 中，并且 class 文件在归档文件中必须存储为 &lt;code&gt;com/mypackage/MyClass.class&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;user class path 可以包含多个路径，在 windows 上，多个路径由分号（;）分割，在 linux 上则是冒号（：）。java 启动器将 user class path 中的字符串存储在 &lt;code&gt;java.class.path&lt;/code&gt; 系统属性中，它的值按以下顺序决定：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;默认值，当前文件夹下的所有 class 文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;CLASSPATH 环境变量中指定的值，覆盖上一设置。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;命令行选项 &lt;code&gt;-classpath&lt;/code&gt;，&lt;code&gt;-cp&lt;/code&gt; 指定的值，覆盖上一设置。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果通过 &lt;code&gt;-jar&lt;/code&gt; 指定的 jar 文件中包含有指定了 &lt;code&gt;Class­-Path&lt;/code&gt; 的 manifest 文件，所有 user class 文件都必须来自于指定的归档文件中。&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;java-运行时如何查找-jar-class-path-classes&#34;&gt;Java 运行时如何查找 JAR­-class-­path Classes&lt;/h1&gt;

&lt;p&gt;当 class 文件只来源于归档文件时，manifest 中可以定义一个 JAR class path, class 文件按以下顺序被访问：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;class 文件被视为它所属的 jar 文件的一部分，jar 文件一般按 manifest 中的条目先后顺序搜索。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;已经被搜索过的 jar 不会被再次搜索，这样可以提升性能并且避免循环搜索。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果一个 jar 文件属于 extension，则其中定义的 JAR class path 会被忽略。所有被 extension 依赖的 class 都会被视为是 JDK 的一部分或者是已经被安装的 extension。&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;javac-和-javadoc-命令如何查找-classes&#34;&gt;javac 和 javadoc 命令如何查找 Classes&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;javac&lt;/code&gt; 和 &lt;code&gt;javadoc&lt;/code&gt; 会在以下两方面使用到 class 文件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用于支持自身的运行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用于解析源代码中的引用。（被引用的类可以是 class 文件的形式或者源代码文件的形式）&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;tools.jar&lt;/code&gt; 仅被用于 &lt;code&gt;javac&lt;/code&gt; 和 &lt;code&gt;javadoc&lt;/code&gt; 的运行，若要用于源代码的解析，需要将其明确的包含在 user class path 中。&lt;/p&gt;

&lt;p&gt;一个程序可以选择引用不同的 &lt;code&gt;java&lt;/code&gt; 平台实现，&lt;code&gt;javac&lt;/code&gt; 和 &lt;code&gt;javadoc&lt;/code&gt; 通过 &lt;code&gt;-­bootclasspath&lt;/code&gt; 和 &lt;code&gt;-­extdirs&lt;/code&gt; 选项提供支持，但这些选项并不会改变这两个工具自身运行时所需要的一系列 class 文件。&lt;/p&gt;

&lt;p&gt;对于 class 文件和源代码文件中的同一个类， &lt;code&gt;javadoc&lt;/code&gt; 优先选择源代码文件。而 &lt;code&gt;javac&lt;/code&gt; 优先选择 class 文件，但会自动从源代码文件重新编译那些已经过期的 class。&lt;/p&gt;

&lt;p&gt;如果指定了 &lt;code&gt;­-sourcepath&lt;/code&gt; 选项，则 &lt;code&gt;javac&lt;/code&gt; 和 &lt;code&gt;javadoc&lt;/code&gt; 会仅仅从指定的源代码路径搜索源代码文件，但依然会从 user class path 中搜索 class 文件。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>