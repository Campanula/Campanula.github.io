<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java Se Tools Reference on 吾月</title>
    <link>http://moonye.me/series/java-se-tools-reference/index.xml</link>
    <description>Recent content in Java Se Tools Reference on 吾月</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="http://moonye.me/series/java-se-tools-reference/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Java SE 命令清单</title>
      <link>http://moonye.me/tech/java-command-reference/</link>
      <pubDate>Sat, 11 Mar 2017 17:34:39 +0800</pubDate>
      
      <guid>http://moonye.me/tech/java-command-reference/</guid>
      <description>

&lt;p&gt;Java SE 命令工具可以用于处理一些开发任务，比如编译和运行程序；将源代码文件打包到 jar 文件中；给 jar 文件使用安全策略等。下面是 JDK 的全套命令，根据相关功能划分为一下几部分：&lt;/p&gt;

&lt;h1 id=&#34;创建应用程序&#34;&gt;创建应用程序&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;appletviewer&lt;/code&gt; 在浏览器外运行 Applets&lt;br /&gt;
&lt;code&gt;extcheck&lt;/code&gt; 检测目标 Java 归档（JAR）文件和当前安装的扩展 JAR 文件之间的版本冲突&lt;br /&gt;
&lt;code&gt;jar&lt;/code&gt; 将多个文件合并为单个JAR文件&lt;br /&gt;
&lt;code&gt;java&lt;/code&gt; 启动一个 Java 程序&lt;br /&gt;
&lt;code&gt;javac&lt;/code&gt; 读取 Java 类和接口定义，并将它们编译成字节码和类文件&lt;br /&gt;
&lt;code&gt;javadoc&lt;/code&gt; 从 Java 源文件中生成 API 文档的 HTML 页面&lt;br /&gt;
&lt;code&gt;javah&lt;/code&gt; 从Java类生成C头文件和源文件&lt;br /&gt;
&lt;code&gt;javap&lt;/code&gt; 分解（Disassembles）一个或多个 class 文件&lt;br /&gt;
&lt;code&gt;jdb&lt;/code&gt; 查找并修复 java 程序中的 bug&lt;br /&gt;
&lt;code&gt;jdeps&lt;/code&gt; Java 类依赖关系分析器&lt;/p&gt;

&lt;h1 id=&#34;安全&#34;&gt;安全&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;keytool&lt;/code&gt; 管理一个存储密钥、X.509证书链和受信任证书的 keystore 数据库&lt;br /&gt;
&lt;code&gt;jarsigner&lt;/code&gt; 签名或者验证 JAR 文件&lt;br /&gt;
&lt;code&gt;policytool&lt;/code&gt; 根据用户在图形工具上的输入，读写一个纯文本的策略文件&lt;/p&gt;

&lt;h1 id=&#34;国际化&#34;&gt;国际化&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;native2ascii&lt;/code&gt; 将任何非 ASCII 字符集的字符转换为 ASCII 或者 Unicode 转义(\uxxxx)字符，反之亦然。&lt;/p&gt;

&lt;h1 id=&#34;远程方法调用-rmi&#34;&gt;远程方法调用（RMI）&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;rmic&lt;/code&gt; 为使用Java远程方法协议（JRMP）或Internet Inter-Orb协议（IIOP）的远程对象生成存根，框架和绑定类。还生成对象管理组（OMG）接口定义语言（IDL）。&lt;br /&gt;
&lt;code&gt;rmiregistry&lt;/code&gt; 在当前主机上的指定端口上启动远程对象注册表。&lt;br /&gt;
&lt;code&gt;rmid&lt;/code&gt; 启动激活系统守护程序，该守护程序使对象能够在Java虚拟机（JVM）中注册和激活。&lt;br /&gt;
&lt;code&gt;serialver&lt;/code&gt; 返回指定类的串行版本UID。&lt;/p&gt;

&lt;h1 id=&#34;java-idl-和-rmi-iiop&#34;&gt;Java IDL 和 RMI­IIOP&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;tnameserv&lt;/code&gt; 启动Java接口定义语言（IDL）名称服务器。&lt;br /&gt;
&lt;code&gt;idlj&lt;/code&gt; 为给定的接口定义语言（IDL）文件生成Java绑定。&lt;br /&gt;
&lt;code&gt;orbd&lt;/code&gt; 使客户端能够在CORBA环境中定位和调用服务器上的持久对象。&lt;br /&gt;
&lt;code&gt;servertool&lt;/code&gt; 为应用程序员注册，注销，启动和关闭服务器提供一个易于使用的界面。&lt;/p&gt;

&lt;h1 id=&#34;部署应用程序和-applets&#34;&gt;部署应用程序和 Applets&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;pack200&lt;/code&gt; 将JAR文件打包到用于Web部署的压缩pack200文件中。&lt;br /&gt;
&lt;code&gt;unpack200&lt;/code&gt; 将由pack200（1）生成的打包文件转换为用于Web部署的JAR文件。&lt;/p&gt;

&lt;h1 id=&#34;java-web-start&#34;&gt;Java Web Start&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;javaws&lt;/code&gt; 启动Java Web Start。&lt;/p&gt;

&lt;h1 id=&#34;监控-java-应用程序&#34;&gt;监控 Java 应用程序&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;jconsole&lt;/code&gt; 启动图形控制台，允许您监视和管理Java应用程序。&lt;br /&gt;
&lt;code&gt;jvisualvm&lt;/code&gt; 对Java应用程序进行可视监视，故障排除和配置文件。&lt;/p&gt;

&lt;h1 id=&#34;监控-jvm&#34;&gt;监控 JVM&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;jps&lt;/code&gt; 实验。列出目标系统上已检测的Java虚拟机（JVM）。&lt;br /&gt;
&lt;code&gt;jstat&lt;/code&gt; 实验。监视JVM统计信息&lt;br /&gt;
&lt;code&gt;jstatd&lt;/code&gt; 实验。监视JVM并启用远程监视工具以附加到JVM。&lt;br /&gt;
&lt;code&gt;jmc&lt;/code&gt; 启动Java Mission Controla工具，用于监视和管理正在运行的Java应用程序和JVM。&lt;/p&gt;

&lt;h1 id=&#34;web-服务&#34;&gt;Web 服务&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;schemagen&lt;/code&gt; 为在Java类中引用的每个名称空间生成一个图式。&lt;br /&gt;
&lt;code&gt;wsgen&lt;/code&gt; 读取Web服务端点实施（SEI）类，并生成Web服务部署和调用所需的所有工件。&lt;br /&gt;
&lt;code&gt;wsimport&lt;/code&gt; 生成可以打包在Web应用程序归档（WAR）文件中的JAX-WS可移植工件，并提供Ant任务。&lt;br /&gt;
&lt;code&gt;xjc&lt;/code&gt; 将一个 XML schema 文件编译到一个全注解的 Java classes 中&lt;/p&gt;

&lt;h1 id=&#34;排查故障&#34;&gt;排查故障&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;jcmd&lt;/code&gt; 将诊断命令请求发送给运行中的 JVM&lt;br /&gt;
&lt;code&gt;jinfo&lt;/code&gt; 实验性的，生成配置信息&lt;br /&gt;
&lt;code&gt;jhat&lt;/code&gt; 实验性的，分析 java 堆&lt;br /&gt;
&lt;code&gt;jhat&lt;/code&gt; 实验性的，打印一个进程、核心文件或者远程调试服务器的共享对象的内存映射或者堆内存细节&lt;br /&gt;
&lt;code&gt;jsadebugd&lt;/code&gt; 实验性的，作为调试服务器绑定到一个 java 进程或者核心文件上&lt;br /&gt;
&lt;code&gt;jstack&lt;/code&gt; 实验性的，打印一个进程、核心文件或者远程调试服务器的 Java 线程的堆栈跟踪&lt;/p&gt;

&lt;h1 id=&#34;脚本&#34;&gt;脚本&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;jrunscript&lt;/code&gt; 实验性的，运行一个支持交互式或者批量式的命令行脚本shell&lt;br /&gt;
&lt;code&gt;jss&lt;/code&gt; 调用 Nashorn 引擎。您可以使用它来解释一个或多个脚本文件，或运行交互式shell&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>设置 Class Path</title>
      <link>http://moonye.me/tech/setting-the-class-path/</link>
      <pubDate>Fri, 10 Mar 2017 22:15:38 +0800</pubDate>
      
      <guid>http://moonye.me/tech/setting-the-class-path/</guid>
      <description>

&lt;p&gt;&lt;code&gt;Class Path&lt;/code&gt; 是 java 运行时环境（JRE）搜索 classes 文件和其他资源文件的路径。&lt;/p&gt;

&lt;h1 id=&#34;概要&#34;&gt;概要&lt;/h1&gt;

&lt;p&gt;class path 可以通过 &lt;code&gt;-classpath&lt;/code&gt; 选项或者 &lt;code&gt;CLASSPATH&lt;/code&gt; 环境变量来设定。前者是更好的方式，每一个程序都可以单独设置而避免对其他程序产生影响。对于新版的 JDK，&lt;code&gt;CLASSPATH&lt;/code&gt; 环境变量不是必须配置的。&lt;/p&gt;

&lt;p&gt;下面等号两边没有空格，等号后可以没有内容，多个路径需使用分隔符，在 windows 系统中使用分号(;) linux 系统中使用冒号(:)分割。路径按指定的顺序优先搜索。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sdkTool -­classpath classpath1:classpath2...
set CLASSPATH=classpath1;classpath2...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;sdkTool&lt;/code&gt; 一个命令行工具，比如 &lt;code&gt;java&lt;/code&gt;,&lt;code&gt;javac&lt;/code&gt;,&lt;code&gt;javadoc&lt;/code&gt; 或者 &lt;code&gt;apt&lt;/code&gt; 等，请参见此处的&lt;a href=&#34;http://docs.oracle.com/javase/8/docs/technotes/tools/index.html&#34; target=&#34;_blank&#34;&gt;列表&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;classpath1:classpath2&lt;/code&gt; 指向 &lt;code&gt;JAR&lt;/code&gt;、&lt;code&gt;zip&lt;/code&gt;、&lt;code&gt;class&lt;/code&gt; 文件的路径。路径需要以文件名或者文件夹结尾：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;JAR/zip 文件&lt;/code&gt; 路径以 JAR 或者 zip 文件名结尾（包括后缀名）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;没有被命名包名的 class 文件&lt;/code&gt; 路径以包含这些 class 文件的目录结尾&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;包下的 class 文件&lt;/code&gt; 路径结尾为包含根包的文件夹。&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;默认路径为当前文件夹，指定 class path 后会覆盖默认值，如果要包含当前路径，需要将一个点(.)包含在 class path 中。不以&lt;code&gt;目录&lt;/code&gt;、&lt;code&gt;JAR/zip文件&lt;/code&gt;、和星号(*)通配符结尾的路径会被忽略。&lt;/p&gt;

&lt;p&gt;注意：一些早期的JDK版本中，默认的 class path 包含了 &lt;code&gt;&amp;lt;jdk­dir&amp;gt;/classes&lt;/code&gt; ，这个目录仅仅被 JDK 工具使用，用户应用程序需要的 classes 应该单独放到 JDK 目录层次外，这样当需要重新安装 JDK 时不需要重新布置应用程序。&lt;/p&gt;

&lt;h1 id=&#34;class-path-通配符&#34;&gt;Class Path 通配符&lt;/h1&gt;

&lt;p&gt;Class Path 中可以包含通配符(*)以匹配一系列的&lt;code&gt;jar&lt;/code&gt;文件，比如 &lt;code&gt;mydir/*&lt;/code&gt; 会匹配 mydir 目录下的所有 jar 文件。这样并不能匹配 class 文件，如果需要同时匹配 jar 和 class 文件，可以使用&lt;code&gt;mydir:mydir/*&lt;/code&gt; 或者 &lt;code&gt;mydir/*:mydir&lt;/code&gt;，书写的先后顺序决定载入的顺序。&lt;/p&gt;

&lt;p&gt;子文件夹不会被递归搜索，比如 &lt;code&gt;mydir/*&lt;/code&gt; 不会搜索 &lt;code&gt;mydir/subdir1&lt;/code&gt; 下的 jar 文件。如果一个文件夹下有多个 jar 文件，这些 jar 文件的载入顺序是不明确的，可能会跟随系统平台而变，结构良好的程序不应该依赖于确定的载入顺序。如果需要明确载入顺序，可以将 jar 文件在 class path 中逐一明确列出。&lt;/p&gt;

&lt;p&gt;通配符会在调用程序主方法前被展开，并被设置为系统属性&lt;code&gt;java.class.path&lt;/code&gt;的值。通配符对&lt;code&gt;CLASSPATH&lt;/code&gt;环境变量和&lt;code&gt;-classpath&lt;/code&gt;选项都有效，但在 jar-manifest 文件的 Class-Path 条目中无效。&lt;/p&gt;

&lt;h1 id=&#34;class-path-和包名&#34;&gt;Class Path 和包名&lt;/h1&gt;

&lt;p&gt;Java 类的包路径与文件系统的目录层次相对应，但是在指定包名时，需要完整的包路径而不是路径的一部分。&lt;code&gt;java.awt.Button&lt;/code&gt; 的包名需要明确指定为 &lt;code&gt;java.awt&lt;/code&gt;。比如一个名为 &lt;code&gt;Cool.class&lt;/code&gt; 的 class 文件，位于 &lt;code&gt;utility.myapp&lt;/code&gt; 包下，位于 &lt;code&gt;C:\java\MyClasses\utility\myapp&lt;/code&gt; 路径之下，你可以使用以下命令运行这个类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java ­-classpath C:\java\MyClasses utility.myapp.Cool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而以下命令无效：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java ­-classpath C:\java\MyClasses\utility myapp.Cool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;包名是 class 的一部分，除非重新编译，否则不能被修改。一个包下的多个 class 可以分布在不同文件夹下。&lt;/p&gt;

&lt;p&gt;对于归档文件中的 class 可以使用以下命令运行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java -­classpath C:\java\MyClasses\myclasses.jar utility.myapp.Cool
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Java 如何查找 Classes</title>
      <link>http://moonye.me/tech/how-classes-are-found/</link>
      <pubDate>Mon, 06 Mar 2017 00:19:52 +0800</pubDate>
      
      <guid>http://moonye.me/tech/how-classes-are-found/</guid>
      <description>

&lt;p&gt;JDK 提供了很多构建 java 程序的工具，比如 java、javac、javadoc、jdb 等。因为 eclipse 、IntelliJ IDEA 等 IDE 给我们提供了极大的便利，我们很少直接接触到这些基本的工具，但在实际的工作中，我们总会碰到与之相关的东西，比如 java 程序的部署和运行。了解这些知识可以让我们更加从容面对复杂的实际情形，Oracle 官方文档对这些话题提供了不错的参考，本系列文章是对&lt;a href=&#34;http://docs.oracle.com/javase/8/docs/technotes/tools/windows/toc.html&#34; target=&#34;_blank&#34;&gt;此处文档&lt;/a&gt;的梳理和总结，后续若有机会的话，会对其中涉及的话题进一步的深入完善。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;java&lt;/code&gt; 命令被用于启动 java 程序，当被调用时，它会从用户的输入和环境中收集信息并引导 java 虚拟机（JVM），由 JVM 处理接下来的工作。&lt;/p&gt;

&lt;h1 id=&#34;java-运行时如何查找-class&#34;&gt;Java 运行时如何查找 Class&lt;/h1&gt;

&lt;p&gt;JVM 会按照顺序依次查找并加载以下三种类：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bootstrap classes&lt;/strong&gt; 它们是构成 java 平台的类，比如位于&lt;code&gt;JDK/jre/lib/&lt;/code&gt;中的 rt.jar 和 其他一些重要的 jar 文件。oracle 官网 tutorial 文档中&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/ext/basics/load.html&#34; target=&#34;_blank&#34;&gt;一处&lt;/a&gt;提到的 i18n.jar，&lt;a href=&#34;https://bugs.openjdk.java.net/browse/JDK-4412570&#34; target=&#34;_blank&#34;&gt;据了解&lt;/a&gt;，已经被 charset.jar 取代，请各位了解准确信息的朋友斧正。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Extension classes&lt;/strong&gt; 位于 &lt;code&gt;JDK/jre/lib/ext&lt;/code&gt; 目录下的 jar 文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;User classes&lt;/strong&gt; 由开发者和第三方定义的 class 文件。通过 &lt;code&gt;-classpath&lt;/code&gt; 命令行选项或者 &lt;code&gt;CLASSPATH&lt;/code&gt; 环境变量指定位置。&lt;/p&gt;

&lt;p&gt;用户一般只需指定 user classes 的位置，Bootstrap classes 和 Extension classes 会被自动处理。&lt;/p&gt;

&lt;h1 id=&#34;java-运行时如何查找-bootstrap-classes&#34;&gt;Java 运行时如何查找 Bootstrap classes&lt;/h1&gt;

&lt;p&gt;指明 Bootstrap classes 位置的信息存储在 &lt;code&gt;sun.boot.class.path&lt;/code&gt; 系统属性中，它在方法 java.lang.System.initProperties 中被初始化，此方法是由 C++ 实现的 Native Method。Bootstrap classes 位置可以使用非标准选项 &lt;code&gt;-Xbootclasspath&lt;/code&gt; 重新指定。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;JDK/lib/tools.jar&lt;/code&gt; 并不属于 Bootstrap classes，但在调起 &lt;code&gt;java&lt;/code&gt; 命令时，它会被自动拓展到 user class path 中，而 &lt;code&gt;javac&lt;/code&gt; 和 &lt;code&gt;javadoc&lt;/code&gt; 命令在处理源代码时，并不会这样。&lt;/p&gt;

&lt;h1 id=&#34;java-运行时如何查找-extension-classes&#34;&gt;Java 运行时如何查找 Extension classes&lt;/h1&gt;

&lt;p&gt;位于 &lt;code&gt;JDK/jre/lib/ext&lt;/code&gt; 的 class 文件必须包含在 jar 或者 zip 文件中，裸 class 文件不会被查找。如果存在多个 jar 文件，而且这些 jar 文件中包含有相同 class，则这种情况下这些 Class 的加载是未定义的行为。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;smart­extension1_0.jar contains class smart.extension.Smart
smart­extension1_1.jar contains class smart.extension.Smart
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;java-运行时如何查找-user-classes&#34;&gt;Java 运行时如何查找 User classes&lt;/h1&gt;

&lt;p&gt;user class path 是一系列包含有 Class 文件的目录、jar文件、zip文件。&lt;/p&gt;

&lt;p&gt;如果 &lt;code&gt;com.mypackage.MyClass&lt;/code&gt; 位于 &lt;code&gt;myclasses&lt;/code&gt; 目录下，则这个目录必须被包含在 user class path 中，class 文件的全路径为 &lt;code&gt;/myclasses/com/mypackage/MyClass.class&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果 &lt;code&gt;com.mypackage.MyClass&lt;/code&gt; 位于一个名为 &lt;code&gt;myclasses.jar&lt;/code&gt; 的归档文件中，则这个归档文件必须被包含在 user class path 中，并且 class 文件在归档文件中必须存储为 &lt;code&gt;com/mypackage/MyClass.class&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;user class path 可以包含多个路径，在 windows 上，多个路径由分号（;）分割，在 linux 上则是冒号（：）。java 启动器将 user class path 中的字符串存储在 &lt;code&gt;java.class.path&lt;/code&gt; 系统属性中，它的值按以下顺序决定：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;默认值，当前文件夹下的所有 class 文件。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;CLASSPATH 环境变量中指定的值，覆盖上一设置。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;命令行选项 &lt;code&gt;-classpath&lt;/code&gt;，&lt;code&gt;-cp&lt;/code&gt; 指定的值，覆盖上一设置。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果通过 &lt;code&gt;-jar&lt;/code&gt; 指定的 jar 文件中包含有指定了 &lt;code&gt;Class­-Path&lt;/code&gt; 的 manifest 文件，所有 user class 文件都必须来自于指定的归档文件中。&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;java-运行时如何查找-jar-class-path-classes&#34;&gt;Java 运行时如何查找 JAR­-class-­path Classes&lt;/h1&gt;

&lt;p&gt;当 class 文件只来源于归档文件时，manifest 中可以定义一个 JAR class path, class 文件按以下顺序被访问：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;class 文件被视为它所属的 jar 文件的一部分，jar 文件一般按 manifest 中的条目先后顺序搜索。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;已经被搜索过的 jar 不会被再次搜索，这样可以提升性能并且避免循环搜索。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果一个 jar 文件属于 extension，则其中定义的 JAR class path 会被忽略。所有被 extension 依赖的 class 都会被视为是 JDK 的一部分或者是已经被安装的 extension。&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;javac-和-javadoc-命令如何查找-classes&#34;&gt;javac 和 javadoc 命令如何查找 Classes&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;javac&lt;/code&gt; 和 &lt;code&gt;javadoc&lt;/code&gt; 会在以下两方面使用到 class 文件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用于支持自身的运行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;用于解析源代码中的引用。（被引用的类可以是 class 文件的形式或者源代码文件的形式）&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;tools.jar&lt;/code&gt; 仅被用于 &lt;code&gt;javac&lt;/code&gt; 和 &lt;code&gt;javadoc&lt;/code&gt; 的运行，若要用于源代码的解析，需要将其明确的包含在 user class path 中。&lt;/p&gt;

&lt;p&gt;一个程序可以选择引用不同的 &lt;code&gt;java&lt;/code&gt; 平台实现，&lt;code&gt;javac&lt;/code&gt; 和 &lt;code&gt;javadoc&lt;/code&gt; 通过 &lt;code&gt;-­bootclasspath&lt;/code&gt; 和 &lt;code&gt;-­extdirs&lt;/code&gt; 选项提供支持，但这些选项并不会改变这两个工具自身运行时所需要的一系列 class 文件。&lt;/p&gt;

&lt;p&gt;对于 class 文件和源代码文件中的同一个类， &lt;code&gt;javadoc&lt;/code&gt; 优先选择源代码文件。而 &lt;code&gt;javac&lt;/code&gt; 优先选择 class 文件，但会自动从源代码文件重新编译那些已经过期的 class。&lt;/p&gt;

&lt;p&gt;如果指定了 &lt;code&gt;­-sourcepath&lt;/code&gt; 选项，则 &lt;code&gt;javac&lt;/code&gt; 和 &lt;code&gt;javadoc&lt;/code&gt; 会仅仅从指定的源代码路径搜索源代码文件，但依然会从 user class path 中搜索 class 文件。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>